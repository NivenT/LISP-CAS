(load "na/pat-match.lisp")
(defun sec (x) (/ (cos x))) (defun cot (x) (/ (tan x))) (defun csc (x) (/ (sin x)))
(defun sech (x) (/ (cosh x))) (defun coth (x) (/ (tanh x))) (defun csch (x) (/ (sinh x)))
(defun eval-opp (x)
	"Returns whether or not x is an operation that will be evaulated by eval normally"
	(member x '(+ - * / expt)))
(defun lisp-opp (x)
	"Returns whether or not x is an operation that can be evaulated by LISP"
	(member x '(+ - * / expt sin cos tan exp log sinh cosh tanh sec cot csc sech coth csch asin acos atan)))
(defun opp (x)
	"Returns whether or not x is an operation"
	(or (lisp-opp x) (pat-match '(d ?x) x) (pat-match '(i ?x) x) (pat-match '(lim ?x ?c) x) ))
(defun unaryp (x)
	"Returns whether or not x is a unary operation"
	;;log is the natural logarithm
	(member x '(sin cos tan log exp sinh cosh tanh sec cot csc sech coth csch)))
(defun commp (x)
	"Returns whether or not x is a communative operation"
	(member x '(+ *)))
(defun inopp (x)
	"Returns whether or not x is an infix operation"
	(member x '(+ - * /)))
(defun inv-op (x)
	"Returns the inverse operation of x"
	(cdr (assoc x '((+ . -) (- . +) (/ . *) (* . /) (log . exp) (exp . log) (sin . asin) (cos . acos) (tan . atan)
		))))
(defun absorb-args (x)
	"Reformats expressions containing lists of args (Ex. (+ (1 2 3) 4) -> (+ 1 2 3 4))"
	(if (and (consp x) (opp (car x)))
		(cons (car x) (loop for arg in (cdr x) append
			(let ((arg (absorb-args arg)))
				(if (and (listp arg) (not (opp (car arg))))
					arg (list arg)))))
		x))
(defun contains (item tree)
	"Returns true iff item appears anywhere in tree"
	(cond	((equalp item tree) t)
			((consp tree) (or (contains item (car tree)) (contains item (cdr tree))))))
(defun gather (lst pred)
	(let ((y nil) (n nil))
		(loop for item in lst do
			(if (funcall pred item)
				(setf y (append y `(,item)))
				(setf n (append n `(,item)))
			))
		(list y n)))
(defun evaluate (expr &key (bindings nil) (eval-all nil))
	"Evaluates all numeric computations in an expression"
	(evaluate-helper (sublis bindings expr) eval-all))
(defun evaluate-helper (expr eval-all)
	(if (and (consp expr) (not (pat-match '(?or (?x) (expt ?x) (/ ?x)) expr)))
		(let ((operands (mapcar #'(lambda (f) (evaluate-helper f eval-all)) (cdr expr))) (op (car expr)))
			(cond
				((and (or (eval-opp op) (and eval-all (lisp-opp op))) (every #'numberp operands))
					(apply op operands))
				((commp op)
					(let ((temp (gather operands #'numberp)))
						(list* op (apply op (car temp)) (cadr temp))))
				((member op '(- /))
					(let ((temp (gather (cdr operands) #'numberp)))
						(list* op (apply (inv-op op) (car temp)) (cadr temp))))
				(t (cons op operands))))
		expr))
;(defun compose (f g)
;	(lambda (&rest args) (funcall f (apply g args))))
(defun compose (&rest funcs)
	(cond	((null funcs) #'identity)
			((= (length funcs) 1) (car funcs))
			;((= (length funcs) 2) (lambda (&rest args) (funcall (car funcs) (apply (cadr funcs) args))))
			(t (lambda (&rest args) (funcall (car funcs) (apply (apply #'compose (cdr funcs)) args))))))
(defun complexity (expr)
	(cond	((consp expr) (+ (length expr) (reduce #'+ (mapcar #'complexity expr))))
			((null expr) 0)
			(t 1)))
(defun simpler? (a b)
	(< (complexity a) (complexity b)))
(defun factors (expr)
	(cond	((pat-match '(* ?*) expr) (mapcan #'factors (cdr expr)))
			((pat-match '(/ ?*) expr) (append (factors (cadr expr))
				(mapcar #'(lambda (f) `(expt ,f -1)) (mapcan #'factors (cddr expr)))))
			((pat-match '(expt ?a ?b) expr) 
				(mapcar #'(lambda (f) `(expt ,f ,(caddr expr))) (factors (cadr expr))))
			(t (list expr))))
(defun u-sub (expr)
	(when (pat-match '((i ?x) ?f) expr)
		(loop for f in (factors (cadr expr)) do
			(when (pat-match '((?op is unaryp) ?x) f)
				(let* ((x (cadar expr)) (y (cadr expr)) (u (cadr f)) (k (simplify `(/ ,y ,f ((d ,x) ,u)) :to-infix nil)))
					;(print k)
					(unless (or (contains x k) (equalp x u))
						(return-from u-sub (simplify `(* ,k ((i ,u) ,f)))))))
			(let* ((x (cadar expr)) (y (cadr expr)) (k (simplify `(/ ,y ,f ((d ,x) ,f)) :to-infix nil)))
				;(print k)
				(unless (or (contains x k) (equalp x f) (equalp k 'UNDEFINED))
					(return-from u-sub (simplify `(* ,k ((i ,f) ,f))))))))
	expr)
(defun ibp (expr)
	(when (pat-match '((i ?x) ?f) expr)
		(let ((facs (factors (cadr expr))))
			(loop for u in facs do
				(let* ((x (cadar expr)) (dv (list* '* (remove u facs :count 1))) (du (simplify `((d ,x) ,u) :to-infix nil)) (v (simplify `((i ,x) ,dv) :to-infix nil)) (f (simplify `(- (* ,u ,v) ((i ,x) (* ,v ,du))) :to-infix nil)))
					;(print f)
					(unless (contains `(i ,x) f)
						(return-from ibp f))
					(when (contains expr f)
						(let ((sol (solve `(,expr = ,f) :var expr :to-infix nil)))
							;(print sol)
							(when (pat-match `(,expr = ?x (?if (not (contains ',expr '?x)))) sol)
								(return-from ibp (caddr sol)))))))))
	expr)
(defparameter *simplification-rules* '(	((?x* (?if (contains 'UNDEFINED '?x*))) = UNDEFINED)
										(((?or + -)) = 0)
										(((?or * /)) = 1)
										(((?or + * /) ?x) = ?x)
										((* ?a* (* ?b*) ?c*) = (* ?a* ?b* ?c*))
										((+ ?a* (+ ?b*) ?c*) = (+ ?a* ?b* ?c*))
										((+ ?a* ?x ?b* ?x ?c*) = (+ (* 2 ?x) ?a* ?b* ?c*))
										((- ?x ?a* ?x ?b*) = (- (+ ?a* ?b*)))
										((- ?x ?a* (- ?x) ?b*) = (+ (* 2 ?x) (- (+ ?a* ?b*))))
										((* ?a* ?x ?b* ?x ?c*) = (* (expt ?x 2) ?a* ?b* ?c*))
										((* ?a* (- ?x) ?b* ?x ?c*) = (* (- (expt ?x 2)) ?a* ?b* ?c*))
										((* ?a* ?x ?b* (- ?x) ?c*) = (* (- (expt ?x 2)) ?a* ?b* ?c*))
										((/ ?x ?a* ?x ?b* (?if (not (equalp '?x 0)))) = (/ 1 ?a* ?b*))
										((/ ?x ?a* (- ?x) ?b*) = (/ -1 ?a* ?b*))
										((/ (- ?x) ?a* ?x ?b*) = (/ -1 ?a* ?b*))
										((+ ?a* 0 ?b*) = (+ ?a* ?b*))
										((- ?x 0) = ?x)
										((- ?x ?a* 0 ?b*) = (- ?x ?a* ?b*))
										((- 0 ?x ?y*) = (- (+ ?x ?y*)))
										((- (- ?x)) = ?x)
										((- (- ?x ?a*)) = (- (+ ?a*) ?x))
										((- ?x ?a* (- ?y) ?b*) = (+ ?x ?y (- (+ ?a* ?b*))))
										((/ ?x ?a* 1 ?b*) = (/ ?x ?a* ?b*))
										((/ ?x ?a* 0 ?b*) = UNDEFINED)
										((/ 0 ?a*) = 0)
										((* ?a* 0 ?b*) = 0)
										((* ?a* 1 ?b*) = (* ?a* ?b*))
										((expt ?x 0) = 1)
										((expt ?x 1) = ?x)
										((+ ?a* ?x ?b* (* ?c* ?x ?d*) ?e*) = (+ (* (+ (* ?c* ?d*) 1) ?x) ?a* ?b* ?e*))
										((+ ?a* (* ?c* ?x ?d*) ?b* ?x ?e*) = (+ (* (+ (* ?c* ?d*) 1) ?x) ?a* ?b* ?e*))
										((+ ?a* (* ?b* ?x ?c*) ?d* (* ?e* ?x ?f*) ?g*) = (+ (* (+ (* ?b* ?c*) (* ?e* ?f*)) ?x) ?a* ?d* ?g*))
									  	((expt ?a) = 0)
									  	((* ?a* (- ?x) ?b* (- ?y) ?c*) = (* ?a* ?x ?b* ?y ?c*))
									  	((log (expt ?a ?b)) = (* ?b (log ?a)))
									  	((log E) = 1)
									  	((expt E (log ?x)) = ?x)
									  	((* ?a* ?x ?b* (/ ?c* ?x ?d*) ?e*) = (* ?a* ?b* (/ ?c* ?d*) ?e*))
									  	((* ?a* (/ ?c* ?x ?d*) ?b* ?x ?e*) = (* ?a* ?b* (/ ?c* ?d*) ?e*))
										((/ (* ?x ?c*) ?d* ?x ?e*) = (/ (* ?c*) ?d* ?e*))
										((/ (* ?b* ?x ?c*) ?d* ?x ?e*) = (/ (* ?b* ?c*) ?d* ?e*))
										((/ ?x ?d* (* ?b* ?x ?c*) ?e*) = (/ 1 (* ?b* ?c*) ?d* ?e*))
										((/ (* ?a* ?x ?b*) ?c* (* ?d* ?x ?e*) ?f*) = (/ (* ?a* ?b*) ?c* (* ?d* ?e*) ?f*))
										((expt E ?x) = (exp ?x))
										((/ (sin ?x) ?a* (cos ?x) ?b*) = (/ (tan ?x) ?a* ?b*))
										((/ ?a ?b* (/ 1 ?c*) ?d*) = (/ (* ?a ?c*) ?b* ?d*))
										((* ?a* -1 ?b* ) = (- (* ?a* ?b*)))
										((* ?a* (- ?b) ?c*) = (- (* ?a* ?b ?c*)))
										((+ ?a* ?x ?b* (- ?x) ?c*) = (+ ?a* ?b* ?c*))
										((+ ?a* (- ?x) ?b* ?x ?c*) = (+ ?a* ?b* ?c*))
										((- ?a ?b* (- ?c ?d*) ?e*) = (- (+ ?a ?d*) ?b* ?c ?e*))
										((+ ?a* (- ?b) ?c*) = (- (+ ?a* ?c*) ?b))
										((expt (- ?x) (?and (?n is integerp) (?n is oddp))) = (- (expt ?x ?n)))
										((expt (- ?x) (?and (?n is integerp) (?n is evenp))) = (expt ?x ?n))
										((- (* ?a* ?x ?b*) ?c* (* ?d* ?x ?e*) ?f*) = (- (* ?x (- (* ?a* ?b*) (* ?d* ?e*))) ?c* ?f*))
										((- (+ ?x ?b*) ?c* (* ?d* ?x ?e*) ?f*) = (- (+ (* ?x (- 1 (* ?d* ?e*))) ?b*) ?c* ?f*))
										((- (* ?a* ?x ?b*) ?c* (+ ?d* ?x ?e*) ?f*) = (- (* (- (+ ?a* ?b*) 1) ?x) ?c* ?f* ?d* ?e*))
										((- (+ ?a* ?x ?b*) ?c* (* ?d* ?x ?e*) ?f*) = (- (+ (* ?x (- 1 (* ?d* ?e*))) ?a* ?b*) ?c* ?f*))
										((cos 0) = 1)
										((sin 0) = 0)
										((cos PI) = -1)
										((sin PI) = 0)
										((cos ((?n is integerp) * PI)) = (expt -1 ?n))
										((sin ((?n is integerp) * PI)) = 0)
										((cos (/ PI 2)) = 0)
										((sin (/ PI 2)) = 1)
										((cos (- ?x)) = (cos ?x))
										((sin (- ?x)) = (- (sin ?x)))
										((expt 1 ?x) = 1)
										((expt 0 ?x) = 0)
										((exp 0) = 1)
										((exp 1) = E)
									) "A list of rules for simplifying expressions")
(defparameter *differentiation-rules* '((((d ?x) ?y (?if (not (contains '?x '?y)))) = 0)
										(((d ?x) ?x) = 1)
										(((d ?x) (- ?f)) = (- ((d ?x) ?f)))
										(((d ?x) (+ ?f ?g*)) = (+ ((d ?x) ?f) ((d ?x) (+ ?g*))))
									 	(((d ?x) (- ?f ?g*)) = (- ((d ?x) ?f) ((d ?x) (+ ?g*))))
									 	(((d ?x) (* ?f ?g)) = (+ (* ((d ?x) ?f) ?g) (* ((d ?x) ?g) ?f)))
									 	(((d ?x) (* ?f ?g ?h*)) = (+ (* (+ (* ((d ?x) ?f) ?g) (* ((d ?x) ?g) ?f)) ?h*) (* ((d ?x) (* ?h*)) ?f ?g)))
									 	(((d ?x) (/ 1 ?f)) = (/ (- ((d ?x) ?f)) (expt ?f 2)))
									 	(((d ?x) (/ ?f ?g)) = (/ (- (* ((d ?x) ?f) ?g) (* ((d ?x) ?g) ?f)) (expt ?g 2)))
									 	(((d ?x) (/ ?f ?g ?h*)) = (+ (/ (/ (- (* ((d ?x) ?f) ?g) (* ((d ?x) ?g) ?f)) (expt ?g 2)) ?h*) (/ (* (- ((d ?x) (* ?h*))) ?f) ?g (expt (* ?h*) 2)))) 
									 	(((d ?x) (expt ?f ?n) (?if (not (contains '?x '?n)))) = (* ((d ?x) ?f) ?n (expt ?f (- ?n 1))))
									 	(((d ?x) (expt ?n ?f) (?if (not (contains '?x '?n)))) = (* ((d ?x) ?f) (log ?n) (expt ?n ?f)))
									 	(((d ?x) (exp ?f)) = (* ((d ?x) ?f) (exp ?f)))
									 	(((d ?x) (log ?f)) = (/ ((d ?x) ?f) ?f))
									 	(((d ?x) (sin ?f)) = (* ((d ?x) ?f) (cos ?f)))
									 	(((d ?x) (cos ?f)) = (* ((d ?x) ?f) (- (sin ?f))))
									 	(((d ?x) (tan ?f)) = (* ((d ?x) ?f) (expt (sec ?f) 2)))
									 	(((d ?x) ?f (?if (not (pat-match '(exp (log ?g)) '?f)))) = ((d ?x) (expt E (log ?f))))
									) "A list of rules for calculating derivatives")
(defparameter *integration-rules* '( 	(((i ?x) ?y (?if (not (contains '?x '?y)))) = (* ?x ?y))
										(((i ?x) ?x) = (/ (expt ?x 2) 2))
										(((i ?x) (+ ?f ?g*)) = (+ ((i ?x) ?f) ((i ?x) (+ ?g*))))
										(((i ?x) (- ?f ?g*)) = (- ((i ?x) ?f) ((i ?x) (+ ?g*))))
										(((i ?x) (* ?f* ?y ?g*) (?if (not (contains '?x '?y)))) = (* ?y ((i ?x) (* ?f* ?g*))))
										(((i ?x) (sin ?x)) = (- (cos ?x)))
										(((i ?x) (cos ?x)) = (sin ?x))
										(((i ?x) (tan ?x)) = (- (log (cos ?x))))
										(((i ?x) (exp ?x)) = (exp ?x))
										;(((i ?x) (log ?x)) = (- (* ?x (log ?x)) ?x))
										(((i ?x) (expt ?n ?x) (?if (not (contains '?x '?n)))) = (/ (expt ?n ?x) (log ?n)))
									) "A list of rules for calculating indefinite integrals")
(defparameter *limit-rules*	'( 	(((lim ?x ?c) ?y (?if (not (contains '?x '?y)))) = ?y)
								(((lim ?x ?c) ?x) = ?c)
								(((lim ?x ?c) ((?op is commp) ?a ?b*)) = (?op ((lim ?x ?c) ?a) ((lim ?x ?c) (?op ?b*))))
							 ) "A list of rules for calculating limits")
;(setf *simplification-rules*
;	(sort *simplification-rules* (lambda (a b) (simpler? (caddr a) (caddr b)))))
;(setf *differentiation-rules*
;	(sort *differentiation-rules* (lambda (a b) (simpler? (caddr a) (caddr b)))))
(defun pre->in (expr)
	"Converts an expression from prefix to infix"
	(if (consp expr)
		(let ((temp (loop for term in expr collect (pre->in term))))
			(cond	((pat-match '((?op is inopp) ?a ?b) temp) 
						(list (cadr temp) (car temp) (caddr temp)))
					((pat-match '((?op is commp) ?x ?a*) temp)
						(list* (cadr temp) (car temp) (pre->in (list* (car temp) (cddr temp)))))
					((pat-match '((?or - /) ?a ?b ?c*) temp)
						(list (cadr temp) (car temp) 
							(pre->in (list* (inv-op (car temp)) (cddr temp)))))
					((pat-match '(expt ?a ?b) temp)
						(list (cadr temp) '^ (caddr temp)))
					(t temp)))
		expr))
(defun in->pre (expr)
	"Converts an expression from infix to prefix"
	(if (consp expr)
		(let ((temp (loop for term in expr collect (in->pre term))))
			(cond	((pat-match '(?a (?op is opp) ?b) temp)
						(list (cadr temp) (car temp) (caddr temp)))
					((pat-match '(?a (?op is commp) ?b*) temp)
						(list (cadr temp) (car temp) (in->pre (cddr temp))))
					((pat-match '(?a ^ ?b) temp)
						(list 'expt (car temp) (caddr temp)))
					(t temp)))
		expr))
(defun simplify (expr &key (to-infix t) (tracep nil))
	"Simplifies an expression"
	(let ((simp (transform (in->pre expr) 
					(append *simplification-rules* *differentiation-rules* *integration-rules* *limit-rules*) 
					:rewrite (compose #'ibp #'u-sub #'evaluate #'absorb-args)
					:tracep tracep)))
			(if to-infix (pre->in simp) simp)))
(defparameter *isolation-rules*	'(	( (?g = ?h (?if (not (contains '?x '?g))) (?if (not (contains '?x '?h)))) -> (?g = ?h) )
									( (?g = ?f (?if (not (contains '?x '?g)))) -> (?f = ?g))
									( ((+ ?g* ?f ?h* (?if (not (contains '?x '?g*))) (?if (not (contains '?x '?h*)))) = ?k (?if (not (contains '?x '?k)))) -> (?f = (- ?k ?g* ?h*)) )
									( ((* ?g* ?f ?h* (?if (not (contains '?x '?g*))) (?if (not (contains '?x '?h*)))) = ?k (?if (not (contains '?x '?k)))) -> (?f = (/ ?k ?g* ?h*)) )
								 	( ((- ?f) = ?k (?if (not (contains '?x '?k)))) -> (?f = (- ?k)) )
								 	( ((- ?f ?g* (?if (not (contains '?x '?g*)))) = ?k (?if (not (contains '?x '?k)))) -> (?f = (+ ?k ?g*)) )
								 	( ((- ?g ?f ?h* (?if (not (contains '?x '?g))) (?if (not (contains '?x '?h*)))) = ?k (?if (not (contains '?x '?k)))) -> (?f = (- ?g ?k ?h*)) )
								 	( ((/ ?f ?g* (?if (not (contains '?x '?g*)))) = ?k (?if (not (contains '?x '?k)))) -> (?f = (* ?k ?g*)) ) 
								 	( ((/ ?g ?f ?h* (?if (not (contains '?x '?g))) (?if (not (contains '?x '?h*)))) = ?k (?if (not (contains '?x '?k)))) -> (?f = (/ ?g ?k ?h*)) )
								 	( ((expt ?f ?n (?if (not (contains '?x '?n)))) = ?k (?if (not (contains '?x '?k)))) -> (?f = (expt ?k (/ 1 ?n))) )
								 	( ((expt ?f ?g) = (expt ?f ?h)) -> (?g = ?h) )
								 	( ((/ ?f ?g*) = ?h) -> (?f = (* ?g* ?h)) )
								 	( (?f = ?g (?if (contains '?x '?f)) (?if (contains '?x '?g))) -> ((- ?f ?g) = 0) )
								 ) "A list of rules for isolating a variable")
(defun solve (expr &key (var 'x) (to-infix t) (tracep nil))
	"Solves simple equations"
	(let ((solved (transform (in->pre expr) *isolation-rules* 
		:rewrite #'(lambda (x) (simplify x :to-infix nil)) 
		:bindings `((?x . ,var))
		:tracep tracep)))
		(when (pat-match '(((?op is unaryp) ?f) = ?k (?if (not (contains '?x '?k))) (?if (inv-op '?op))) solved `((?x . ,var)))
			(setf solved (solve (list (cadar solved) '= (list (inv-op (caar solved)) (caddr solved))) :var var :to-infix to-infix)))
		(if to-infix (pre->in solved) solved)))
(defun solve-system-helper (vars equations &optional (known nil))
	(loop for eqn in equations do
		(loop for var in vars do
			(let ((sol (solve eqn :var var)))
				(if (eq (car sol) var)
					(return-from solve-system-helper 
						(solve-system-helper 	(remove var vars) 
												(subst 
													(caddr sol) 
													(car sol) 
													(remove eqn equations)) 
												(append known `(,sol))))))))
	known)
(defun solve-system (vars &rest equations)
	"Solves simple systems of equations"
	(let ((sol (solve-system-helper vars equations)))
		(solve-system-helper vars (sort sol #'simpler?))))
(defun differentiate (expression &key (var 'x) (to-infix t))
	"Calculates the derivative of expression with respect to var"
	(simplify `((d ,var) ,expression) :to-infix to-infix))
(defun integrate (expression &key (low nil) (high nil) (var 'x) (to-infix t))
	"Calculates the definite or indefinite integral of expression with respect to var"
	(if (or (null low) (null high))
		(simplify `(((i ,var) ,expression) + c) :to-infix to-infix)
		(let ((F (simplify `((i ,var) ,expression))))
			(simplify `(,(evaluate F :bindings `((,var . ,high))) - ,(evaluate F :bindings `((,var . ,low)))) :to-infix to-infix))))
(defun fac (n)
	"Computes n!"
	(if (<= n 1) 1 (* n (fac (1- n)))))
(defun taylor (expr &key (c 0) (n 6) (var 'x) (to-infix t))
	"Computes the Taylor series about c of expr out to n terms"
	(do (	(f expr (differentiate f :var var))
			(terms nil (append terms (list (simplify `((,(evaluate f :bindings `((,var . ,c))) * ((,var - ,c) ^ ,i)) / ,(fac i))))))
			(i 0 (1+ i)))
		((or (= i n) (equalp f 0)) (simplify (list* '+ terms) :to-infix to-infix))))
(defun expr->string (e)
	(cond
		((pat-match '((?op is commp) ?x) e)
			(expr->string (cadr e)))
		((pat-match '(+ ?x ?y*) e) (format nil "~a + ~a" 
			(expr->string (cadr e)) (expr->string (list* (car e) (cddr e)))))
		((and (pat-match '(* ?x ?y*) e) (every #'numberp (cdr e))) (format nil "~a * ~a"
			(expr->string (cadr e)) (expr->string (list* (car e) (cddr e))))) 
		((pat-match '(* ?x ?y*) e) 
			(let ((temp (gather (cdr e) #'numberp))) (if (= (length (car temp)) 1)
				(format nil "~a~{~a~}" (caar temp) (cadr temp))
				(format nil "(~a)~{~a~}" (expr->string (list* '* (car temp))) (cadr temp)))))
		((pat-match '((?or - /) ?x ?y*) e) (if (= (length (cddr e)) 1)
			(format nil "~a ~a ~a" (cadr e) (car e) (caddr e))
			(format nil "~a ~a (~a)" 
				(cadr e) (car e) (expr->string (list* (inv-op (car e)) (cddr e))))))
		(t (write-to-string e))
	))