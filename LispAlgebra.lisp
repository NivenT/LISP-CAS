(load "pat-match.lisp")
(defun opp (x)
	"Returns whether or not x is an operation"
	(member x '(+ - * / expt sin cos tan log exp)))
(defun unaryp (x)
	"Returns whether or not x is a unary operation"
	(member x '(sin cos tan log exp))) ;;log is the natural logarithm
(defun commp (x)
	"Returns whether or not x is a communative operation"
	(member x '(+ *)))
(defun inopp (x)
	"Returns whether or not x is an infix operation"
	(member x '(+ - * /)))
(defun inv-op (x)
	"Returns the inverse operation of x"
	(cdr (assoc x '((+ . -) (- . +) (/ . *) (* . /) (log . exp) (exp . log)))))
(defun absorb-args (x)
	"Reformats expressions containing lists of args (Ex. (+ (1 2 3) 4) -> (+ 1 2 3 4)"
	(if (and (consp x) (opp (car x)))
		(cons (car x) (loop for arg in (cdr x) append
			(if (and (listp arg) (not (opp (car arg))))
				arg (list arg))))
		x))
(defun contains (item tree)
	"Returns true iff item appears anywhere in tree"
	(cond	((equalp item tree) t)
			((consp tree) (or (contains item (car tree)) (contains item (cdr tree))))))
(defun evaluate (expr &optional (bindings nil))
	"Evaluates all numeric computations in an expression"
	(evaluate-helper (sublis bindings expr)))
(defun evaluate-helper (expr)
	(if (consp expr)
		(let ((operands (mapcar #'evaluate-helper (cdr expr))) (op (car expr)))
			(if (and (opp op) (every #'numberp operands)) 
				(apply op operands) (cons op operands)))
		expr))
(defun compose (f g)
	(lambda (&rest args) (funcall f (apply g args))))
(defun mymap (func lst)
	(if (listp lst) (mapcar func lst) (mapcar func (list lst))))
(defparameter *simplification-rules* '(	((?x* (?if (contains 'UNDEFINED '?x*))) = UNDEFINED)
										(((?or + -)) = 0)
										(((?or * /)) = 1)
										(((?or + *) ?x) = ?x)
										((/ ?x) = (/ 1 ?x))
										((* ?a* (* ?b*) ?c*) = (* ?a* ?b* ?c*))
										((+ ?a* (+ ?b*) ?c*) = (+ ?a* ?b* ?c*))
										((+ ?a* ?x ?b* ?x ?c*) = (+ (* 2 ?x) ?a* ?b* ?c*))
										((- ?x ?a* ?x ?b*) = (- (+ ?a* ?b*)))
										((- ?x ?a* (- ?x) ?b*) = (+ (* 2 ?x) (- (+ ?a* ?b*))))
										((* ?a* ?x ?b* ?x ?c*) = (* (expt ?x 2) ?a* ?b* ?c*))
										((* ?a* (- ?x) ?b* ?x ?c*) = (* (- (^ ?x 2)) ?a* ?b* ?c*))
										((* ?a* ?x ?b* (- ?x) ?c*) = (* (- (^ ?x 2)) ?a* ?b* ?c*))
										((/ ?x ?a* ?x ?b*) = (/ 1 ?a* ?b*))
										((/ ?x ?a* (- ?x) ?b*) = (/ -1 ?a* ?b*))
										((/ (- ?x) ?a* ?x ?b*) = (/ -1 ?a* ?b*))
										((+ ?a* 0 ?b*) = (+ ?a* ?b*))
										((- ?x ?a* 0 ?b*) = (- ?x ?a* ?b*))
										((- 0 ?x*) = (- (+ ?x*)))
										((- (- ?x ?a*)) = (- (+ ?a*) ?x))
										((- ?x ?a* (- ?y) ?b*) = (+ ?x ?y (- (+ ?a* ?b*))))
										((/ ?x ?a* 1 ?b*) = (/ ?x ?a* ?b*))
										((/ ?x ?a* 0 ?b*) = UNDEFINED)
										((/ 0 ?a*) = 0)
										((* ?a* 0 ?b*) = 0)
										((* ?a* 1 ?b*) = (* ?a* ?b*))
										((expt ?x 0) = 1)
										((expt ?x 1) = ?x)
									  ) "A list of rules for simplifying expressions")
(defun pre->in (expr)
	"Converts an expression from prefix to infix"
	(if (consp expr)
		(let ((temp (loop for term in expr collect (pre->in term))))
			(cond	((pat-match '((?op is inopp) ?a ?b) temp) 
						(list (cadr temp) (car temp) (caddr temp)))
					((pat-match '((?op is commp) ?x ?a*) temp)
						(list* (cadr temp) (car temp) (pre->in (list* (car temp) (cddr temp)))))
					((pat-match '((?or - /) ?a ?b ?c*) temp)
						(list (cadr temp) (car temp) 
							(pre->in (list* (inv-op (car temp)) (cddr temp)))))
					(t temp)))
		expr))
(defun in->pre (expr)
	"Converts an expression from infix to prefix"
	(if (consp expr)
		(let ((temp (loop for term in expr collect (in->pre term))))
			(cond	((pat-match '(?a (?op is opp) ?b) temp)
						(list (cadr temp) (car temp) (caddr temp)))
					((pat-match '(?a (?op is commp) ?b*) temp)
						(list (cadr temp) (car temp) (in->pre (cddr temp))))
					(t temp)))
		expr))
(defun simplify (expr)
	"Simplifies an expression"
	(pre->in (transform (in->pre expr) *simplification-rules* 
		:rewrite (compose #'evaluate #'absorb-args))))