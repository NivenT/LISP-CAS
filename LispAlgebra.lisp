(load "pat-match.lisp")
(defun lisp-opp (x)
	"Returns whether or not x is an operation that can be evaulated by LISP"
	(member x '(+ - * / expt sin cos tan log exp sinh cosh)))
(defun opp (x)
	"Returns whether or not x is an operation"
	(or (lisp-opp x) (pat-match '(d ?x) x) (pat-match '(i ?x) x)))
(defun unaryp (x)
	"Returns whether or not x is a unary operation"
	(member x '(sin cos tan log exp))) ;;log is the natural logarithm
(defun commp (x)
	"Returns whether or not x is a communative operation"
	(member x '(+ *)))
(defun inopp (x)
	"Returns whether or not x is an infix operation"
	(member x '(+ - * /)))
(defun inv-op (x)
	"Returns the inverse operation of x"
	(cdr (assoc x '((+ . -) (- . +) (/ . *) (* . /) (log . exp) (exp . log)))))
(defun absorb-args (x)
	"Reformats expressions containing lists of args (Ex. (+ (1 2 3) 4) -> (+ 1 2 3 4)"
	(if (and (consp x) (opp (car x)))
		(cons (car x) (loop for arg in (cdr x) append
			(let ((arg (absorb-args arg)))
				(if (and (listp arg) (not (opp (car arg))))
					arg (list arg)))))
		x))
(defun contains (item tree)
	"Returns true iff item appears anywhere in tree"
	(cond	((equalp item tree) t)
			((consp tree) (or (contains item (car tree)) (contains item (cdr tree))))))
(defun evaluate (expr &optional (bindings nil))
	"Evaluates all numeric computations in an expression"
	(evaluate-helper (sublis bindings expr)))
(defun evaluate-helper (expr)
	(if (and (consp expr) (not (pat-match '(?or (?x) (expt ?x) (/ ?x)) expr)))
		(let ((operands (mapcar #'evaluate-helper (cdr expr))) (op (car expr)))
			(if (and (lisp-opp op) (every #'numberp operands)) 
				(apply op operands) (cons op operands)))
		expr))
(defun compose (f g)
	(lambda (&rest args) (funcall f (apply g args))))
(defun complexity (expr)
	(cond	((consp expr) (+ (length expr) (reduce #'+ (mapcar #'complexity expr))))
			((null expr) 0)
			(t 1)))
(defun simpler? (a b)
	(< (complexity a) (complexity b)))
(defparameter *const-1* `((E . 2.718281828) (PI . ,*pi*)))
(defparameter *const-2* `((2.718281828 . E) (,*pi* . PI)))
(defparameter *simplification-rules* '(	((?x* (?if (contains 'UNDEFINED '?x*))) = UNDEFINED)
										(((?or + -)) = 0)
										(((?or * /)) = 1)
										(((?or + * /) ?x) = ?x)
										((* ?a* (* ?b*) ?c*) = (* ?a* ?b* ?c*))
										((+ ?a* (+ ?b*) ?c*) = (+ ?a* ?b* ?c*))
										((+ ?a* ?x ?b* ?x ?c*) = (+ (* 2 ?x) ?a* ?b* ?c*))
										((- ?x ?a* ?x ?b*) = (- (+ ?a* ?b*)))
										((- ?x ?a* (- ?x) ?b*) = (+ (* 2 ?x) (- (+ ?a* ?b*))))
										((* ?a* ?x ?b* ?x ?c*) = (* (expt ?x 2) ?a* ?b* ?c*))
										((* ?a* (- ?x) ?b* ?x ?c*) = (* (- (expt ?x 2)) ?a* ?b* ?c*))
										((* ?a* ?x ?b* (- ?x) ?c*) = (* (- (expt ?x 2)) ?a* ?b* ?c*))
										((/ ?x ?a* ?x ?b* (?if (not (equalp ?x 0)))) = (/ 1 ?a* ?b*))
										((/ ?x ?a* (- ?x) ?b*) = (/ -1 ?a* ?b*))
										((/ (- ?x) ?a* ?x ?b*) = (/ -1 ?a* ?b*))
										((+ ?a* 0 ?b*) = (+ ?a* ?b*))
										((- ?x ?a* 0 ?b*) = (- ?x ?a* ?b*))
										((- 0 ?x ?y*) = (- (+ ?x ?y*)))
										((- (- ?x)) = ?x)
										((- (- ?x ?a*)) = (- (+ ?a*) ?x))
										((- ?x ?a* (- ?y) ?b*) = (+ ?x ?y (- (+ ?a* ?b*))))
										((/ ?x ?a* 1 ?b*) = (/ ?x ?a* ?b*))
										((/ ?x ?a* 0 ?b*) = UNDEFINED)
										((/ 0 ?a*) = 0)
										((* ?a* 0 ?b*) = 0)
										((* ?a* 1 ?b*) = (* ?a* ?b*))
										((expt ?x 0) = 1)
										((expt ?x 1) = ?x)
										((+ ?a* ?x ?b* (* ?c* ?x ?d*) ?e*) = (+ (* (+ (* ?c* ?d*) 1) ?x) ?a* ?b* ?e*))
										((+ ?a* (* ?c* ?x ?d*) ?b* ?x ?e*) = (+ (* (+ (* ?c* ?d*) 1) ?x) ?a* ?b* ?e*))
										((+ ?a* (* ?b* ?x ?c*) ?d* (* ?e* ?x ?f*) ?g*) = (+ (* (+ (* ?b* ?c*) (* ?e* ?f*)) ?x) ?a* ?d* ?g*))
									  	((expt ?a) = 0)
									  ) "A list of rules for simplifying expressions")
(defparameter *differentiation-rules* '((((d ?x) ?y (?if (not (contains '?x '?y)))) = 0)
										(((d ?x) ?x) = 1)
										(((d ?x) (+ ?f ?g*)) = (+ ((d ?x) ?f) ((d ?x) (+ ?g*))))
									 	(((d ?x) (- ?f ?g*)) = (- ((d ?x) ?f) ((d ?x) (+ ?g*))))
									 	(((d ?x) (* ?f ?g)) = (+ (* ((d ?x) ?f) ?g) (* ((d ?x) ?g) ?f)))
									 	(((d ?x) (* ?f ?g ?h*)) = (+ (* (+ (* ((d ?x) ?f) ?g) (* ((d ?x) ?g) ?f)) ?h*) (* ((d ?x) (* ?h*)) ?f ?g)))
									 	(((d ?x) (/ 1 ?f)) = (/ (- ((d ?x) ?f)) (expt ?f 2)))
									 	(((d ?x) (/ ?f ?g)) = (/ (- (* ((d ?x) ?f) ?g) (* ((d ?x) ?g) ?f)) (expt ?g 2)))
									 	(((d ?x) (/ ?f ?g ?h*)) = (+ (/ (/ (- (* ((d ?x) ?f) ?g) (* ((d ?x) ?g) ?f)) (expt ?g 2)) ?h*) (/ (* (- ((d ?x) (* ?h*))) ?f) ?g (expt (* ?h*) 2)))) 
									 	(((d ?x) (expt ?f (?n is numberp))) = (* ((d ?x) ?f) ?n (expt ?f (- ?n 1))))
									 	(((d ?x) (expt (?n is numberp) ?f)) = (* ((d ?x) ?f) (log ?n) (expt ?n ?f)))
									 ) "A list of rules for calculating derivatives")
(setf *simplification-rules*
	(sort *simplification-rules* (lambda (a b) (simpler? (caddr a) (caddr b)))))
(setf *differentiation-rules*
	(sort *differentiation-rules* (lambda (a b) (simpler? (caddr a) (caddr b)))))
(defun pre->in (expr)
	"Converts an expression from prefix to infix"
	(if (consp expr)
		(let ((temp (loop for term in expr collect (pre->in term))))
			(cond	((pat-match '((?op is inopp) ?a ?b) temp) 
						(list (cadr temp) (car temp) (caddr temp)))
					((pat-match '((?op is commp) ?x ?a*) temp)
						(list* (cadr temp) (car temp) (pre->in (list* (car temp) (cddr temp)))))
					((pat-match '((?or - /) ?a ?b ?c*) temp)
						(list (cadr temp) (car temp) 
							(pre->in (list* (inv-op (car temp)) (cddr temp)))))
					((pat-match '(expt ?a ?b) temp)
						(list (cadr temp) '^ (caddr temp)))
					(t temp)))
		expr))
(defun in->pre (expr)
	"Converts an expression from infix to prefix"
	(if (consp expr)
		(let ((temp (loop for term in expr collect (in->pre term))))
			(cond	((pat-match '(?a (?op is opp) ?b) temp)
						(list (cadr temp) (car temp) (caddr temp)))
					((pat-match '(?a (?op is commp) ?b*) temp)
						(list (cadr temp) (car temp) (in->pre (cddr temp))))
					((pat-match '(?a ^ ?b) temp)
						(list 'expt (car temp) (caddr temp)))
					(t temp)))
		expr))
(defun simplify (expr &optional (to-infix t))
	"Simplifies an expression"
	(let ((simp (sublis *const-2* (transform (sublis *const-1* (in->pre expr)) 
		(append *simplification-rules* *differentiation-rules*) 
		:rewrite (compose #'evaluate #'absorb-args)))))
			(if to-infix (pre->in simp) simp)))